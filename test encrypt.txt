This function worked but was a bit slow. Also too confusing and long.

func encryptFile(application fyne.App, files []string, key []byte, method string, deleteAfter bool) {
	var wg sync.WaitGroup

	for _, filePath := range files {
		wg.Add(1)
		go func(filePath string) {
			defer wg.Done()

			// Start tracking time for encryption
			startTime := time.Now()

			// Check if the file is already encrypted
			if strings.HasSuffix(filePath, ".enc") {
				fmt.Printf("File %s is already encrypted. Skipping...\n", filePath)
				return
			}

			// Generate a unique salt for each file
			salt, err := encryption.GenerateSalt()
			if err != nil {
				fmt.Printf("Error generating salt for %s: %v\n", filePath, err)
				return
			}

			// Derive the encryption key using the password and unique salt
			derivedKey := encryption.DeriveKey(string(key), salt)

			// Ensure key length is 32 bytes
			if len(derivedKey) != 32 {
				fmt.Println("Error: Derived key length is not 32 bytes")
				return
			}

			// Open the source file
			sourceFile, err := os.Open(filePath)
			if err != nil {
				fmt.Printf("Error opening file %s: %v\n", filePath, err)
				return
			}
			defer sourceFile.Close()

			// Create a temporary file for encrypted data
			tmpFile, err := os.CreateTemp(filepath.Dir(filePath), "*.tmp")
			if err != nil {
				fmt.Printf("Error creating temporary file: %v\n", err)
				return
			}
			defer tmpFile.Close()

			// Get the file size for progress tracking
			fileInfo, err := sourceFile.Stat()
			if err != nil {
				fmt.Printf("Error getting file info for %s: %v\n", filePath, err)
				return
			}

			// Prepare progress bar and custom writer
			progressBar, win := ui.ShowProgressBar(application, "GoCrypt - Encryption Progress", 100)
			progressWriter := ui.NewProgressWriter(progressBar, fileInfo.Size())

			// Use MultiWriter to write to both the temp file and update the progress bar
			multiWriter := io.MultiWriter(tmpFile, progressWriter)

			// Encrypt the file using a buffer
			buffer := make([]byte, bufSize)
			for {
				n, err := sourceFile.Read(buffer)
				if err != nil && err != io.EOF {
					fmt.Printf("Error reading file: %v\n", err)
					break
				}
				if n == 0 {
					break
				}

				// Apply layered encryption
				encryptedChunk := buffer[:n]
				for i := 0; i < defaultLayers; i++ {
					encryptedChunk, err = encryption.EncryptData(encryptedChunk, derivedKey, method)
					if err != nil {
						fmt.Printf("Error during encryption layer %d: %v\n", i+1, err)
						win.Close()
						return
					}
				}

				// Write the encrypted chunk to the temp file and progress bar
				if _, err := multiWriter.Write(encryptedChunk); err != nil {
					fmt.Printf("Error writing encrypted data: %v\n", err)
					break
				}
			}

			// Complete encryption process
			tmpFile.Close()
			os.Rename(tmpFile.Name(), filePath+".enc")

			// Print time taken for encryption
			fmt.Printf("File %s encrypted in %v\n", filePath, time.Since(startTime))
			win.Close()
		}(filePath)
	}

	wg.Wait() // Wait for all goroutines to finish
	fmt.Println("All files have been encrypted.")
}